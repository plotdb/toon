// Generated by LiveScript 1.6.0
var encoder, ref$, decoder, encode, decode;
encoder = function(options){
  options == null && (options = {});
  this.indent = 2;
  this.delimiter = ',';
  this.lengthMarker = false;
  import$(this, options);
  return this;
};
encoder.prototype = (ref$ = Object.create(Object.prototype), ref$.constructor = encoder, ref$.encode = function(value){
  var keys, lines;
  switch (false) {
  case value !== null:
    return 'null';
  case value !== undefined:
    return 'null';
  case !(typeof value === 'object' && value !== null && !Array.isArray(value)):
    keys = Object.keys(value);
    if (keys.length === 0) {
      return '';
    } else {
      return this.encodeObject(value, 0);
    }
  case !Array.isArray(value):
    lines = this.encodeArray(value, 0, null);
    return lines.join('\n');
  default:
    return this.encodePrimitive(value);
  }
}, ref$.encodeObject = function(obj, depth){
  var lines, indentStr, key, value, formattedKey, valueLines;
  lines = [];
  indentStr = repeatString$(' ', depth * this.indent);
  for (key in obj) {
    value = obj[key];
    formattedKey = this.formatKey(key);
    valueLines = this.encodeValue(value, depth, formattedKey);
    lines = lines.concat(valueLines);
  }
  return lines.join('\n');
}, ref$.encodeValue = function(value, depth, key){
  var indentStr, header, keys, objLines, lines;
  indentStr = repeatString$(' ', depth * this.indent);
  if (value === null || value === undefined) {
    return [indentStr + "" + key + ": null"];
  } else if (typeof value === 'boolean') {
    return [indentStr + "" + key + ": " + value];
  } else if (typeof value === 'number') {
    return [indentStr + "" + key + ": " + this.normalizeNumber(value)];
  } else if (typeof value === 'bigint') {
    return [indentStr + "" + key + ": " + String(value)];
  } else if (value instanceof Date) {
    return [indentStr + "" + key + ": " + this.quoteString(value.toISOString())];
  } else if (typeof value === 'string') {
    return [indentStr + "" + key + ": " + this.encodeString(value)];
  } else if (typeof value === 'function' || typeof value === 'symbol') {
    return [indentStr + "" + key + ": null"];
  } else if (typeof value === 'object' && value !== null && !Array.isArray(value)) {
    header = indentStr + "" + key + ":";
    keys = Object.keys(value);
    if (keys.length === 0) {
      return [header];
    } else {
      objLines = this.encodeObject(value, depth + 1);
      lines = [header].concat(objLines.split('\n'));
      return lines;
    }
  } else if (Array.isArray(value)) {
    return this.encodeArray(value, depth, key);
  } else {
    return [indentStr + "" + key + ": null"];
  }
}, ref$.encodeArray = function(arr, depth, key){
  var len, lenMarker, indentStr, delim, delimMarker, allPrimitives, values, valuesStr, suffix, this$ = this;
  len = arr.length;
  lenMarker = this.lengthMarker ? "#" + len : len;
  indentStr = repeatString$(' ', depth * this.indent);
  delim = this.delimiter;
  delimMarker = delim === ',' ? '' : delim;
  if (this.isTabular(arr)) {
    return this.formatTabular(arr, depth, key, lenMarker);
  } else {
    allPrimitives = arr.every(function(el){
      return this$.isPrimitive(el);
    });
    if (allPrimitives) {
      values = arr.map(function(el){
        return this$.encodePrimitive(el);
      });
      valuesStr = values.join(delim);
      suffix = valuesStr ? ": " + valuesStr : ":";
      if (key != null) {
        return [indentStr + "" + key + "[" + lenMarker + delimMarker + "]" + suffix];
      } else {
        return ["[" + lenMarker + delimMarker + "]" + suffix];
      }
    } else {
      return this.formatList(arr, depth, key, lenMarker);
    }
  }
}, ref$.isTabular = function(arr){
  var firstKeys, this$ = this;
  if (arr.length === 0) {
    return false;
  }
  if (!arr.every(function(el){
    return typeof el === 'object' && el !== null && !Array.isArray(el);
  })) {
    return false;
  }
  firstKeys = Object.keys(arr[0]).sort();
  if (firstKeys.length === 0) {
    return false;
  }
  if (!arr.every(function(obj){
    var keys;
    keys = Object.keys(obj).sort();
    return keys.length === firstKeys.length && keys.every(function(k, i){
      return k === firstKeys[i];
    });
  })) {
    return false;
  }
  return arr.every(function(obj){
    return Object.values(obj).every(function(v){
      return this$.isPrimitive(v);
    });
  });
}, ref$.isPrimitive = function(value){
  var ref$;
  return value === null || value === undefined || ((ref$ = typeof value) === 'string' || ref$ === 'number' || ref$ === 'boolean' || ref$ === 'bigint') || value instanceof Date;
}, ref$.formatTabular = function(arr, depth, key, lenMarker){
  var indentStr, rowIndent, delim, delimMarker, fields, formattedFields, fieldsStr, header, rows, this$ = this;
  indentStr = repeatString$(' ', depth * this.indent);
  rowIndent = repeatString$(' ', (depth + 1) * this.indent);
  delim = this.delimiter;
  delimMarker = delim === ',' ? '' : delim;
  fields = Object.keys(arr[0]);
  formattedFields = fields.map(function(f){
    return this$.formatKey(f);
  });
  fieldsStr = formattedFields.join(delim);
  header = key != null
    ? indentStr + "" + key + "[" + lenMarker + delimMarker + "]{" + fieldsStr + "}:"
    : "[" + lenMarker + delimMarker + "]{" + fieldsStr + "}:";
  rows = arr.map(function(obj){
    var values;
    values = fields.map(function(field){
      return this$.encodePrimitive(obj[field]);
    });
    return rowIndent + "" + values.join(delim);
  });
  return [header].concat(rows);
}, ref$.formatList = function(arr, depth, key, lenMarker){
  var indentStr, itemIndent, delim, delimMarker, header, lines, i$, len$, item, keys, firstKey, formattedFirstKey, firstValue, firstLine, j$, to$, i, k, formattedK, vLines, innerLen, innerLenMarker, innerDelimMarker, values, valuesStr, this$ = this;
  indentStr = repeatString$(' ', depth * this.indent);
  itemIndent = repeatString$(' ', (depth + 1) * this.indent);
  delim = this.delimiter;
  delimMarker = delim === ',' ? '' : delim;
  header = key != null
    ? indentStr + "" + key + "[" + lenMarker + delimMarker + "]:"
    : "[" + lenMarker + delimMarker + "]:";
  lines = [header];
  for (i$ = 0, len$ = arr.length; i$ < len$; ++i$) {
    item = arr[i$];
    if (typeof item === 'object' && item !== null && !Array.isArray(item)) {
      keys = Object.keys(item);
      if (keys.length > 0) {
        firstKey = keys[0];
        formattedFirstKey = this.formatKey(firstKey);
        firstValue = this.encodeValue(item[firstKey], depth + 1, formattedFirstKey);
        firstLine = firstValue[0].replace(/^\s+/, itemIndent + "- ");
        lines.push(firstLine);
        for (j$ = 1, to$ = keys.length; j$ < to$; ++j$) {
          i = j$;
          k = keys[i];
          formattedK = this.formatKey(k);
          vLines = this.encodeValue(item[k], depth + 1, formattedK);
          lines = lines.concat(vLines);
        }
      } else {
        lines.push(itemIndent + "-");
      }
    } else if (Array.isArray(item)) {
      innerLen = item.length;
      innerLenMarker = this.lengthMarker ? "#" + innerLen : innerLen;
      innerDelimMarker = delim === ',' ? '' : delim;
      values = item.map(fn$);
      valuesStr = values.join(delim);
      lines.push(itemIndent + "- [" + innerLenMarker + innerDelimMarker + "]: " + valuesStr);
    } else {
      lines.push(itemIndent + "- " + this.encodePrimitive(item));
    }
  }
  return lines;
  function fn$(el){
    return this$.encodePrimitive(el);
  }
}, ref$.encodePrimitive = function(value){
  switch (false) {
  case value !== null:
    return 'null';
  case value !== undefined:
    return 'null';
  case typeof value !== 'boolean':
    return String(value);
  case typeof value !== 'number':
    return this.normalizeNumber(value);
  case typeof value !== 'bigint':
    return String(value);
  case !(value instanceof Date):
    return this.quoteString(value.toISOString());
  case typeof value !== 'string':
    return this.encodeString(value);
  case typeof value !== 'function':
    return 'null';
  case typeof value !== 'symbol':
    return 'null';
  default:
    return 'null';
  }
}, ref$.normalizeNumber = function(num){
  var str;
  if (!isFinite(num)) {
    return 'null';
  }
  if (num === 0 || num === -0) {
    return '0';
  }
  str = String(num);
  if (/e/i.test(str)) {
    if (num > 0 && num < 1) {
      str = num.toFixed(20);
    } else if (Math.abs(num) > 1e15) {
      str = num.toFixed(0);
    } else {
      str = num.toFixed(10);
    }
    str = str.replace(/\.?0+$/, '');
  }
  return str;
}, ref$.encodeString = function(str){
  if (this.shouldQuote(str)) {
    return this.quoteString(str);
  } else {
    return str;
  }
}, ref$.shouldQuote = function(str){
  if (str === '') {
    return true;
  }
  if (str[0] === ' ' || str[str.length - 1] === ' ') {
    return true;
  }
  if (str.indexOf(this.delimiter) >= 0) {
    return true;
  }
  if (str.indexOf(':') >= 0) {
    return true;
  }
  if (str.indexOf('"') >= 0) {
    return true;
  }
  if (str.indexOf('\\') >= 0) {
    return true;
  }
  if (/[\x00-\x1F]/.test(str)) {
    return true;
  }
  if (str === 'true' || str === 'false' || str === 'null') {
    return true;
  }
  if (/^-?\d+(\.\d+)?([eE][+-]?\d+)?$/.test(str)) {
    return true;
  }
  if (str.startsWith('- ')) {
    return true;
  }
  if (/^\[.*\]$/.test(str)) {
    return true;
  }
  if (/^\{.*\}$/.test(str)) {
    return true;
  }
  return false;
}, ref$.quoteString = function(str){
  var escaped;
  escaped = str.replace(/\\/g, '\\\\').replace(/"/g, '\\"').replace(/\n/g, '\\n').replace(/\r/g, '\\r').replace(/\t/g, '\\t');
  return "\"" + escaped + "\"";
}, ref$.formatKey = function(key){
  if (/^[a-zA-Z_][a-zA-Z0-9_\.]*$/.test(key)) {
    return key;
  } else {
    return this.quoteString(key);
  }
}, ref$);
decoder = function(options){
  options == null && (options = {});
  this.strict = false;
  import$(this, options);
  return this;
};
decoder.prototype = (ref$ = Object.create(Object.prototype), ref$.constructor = decoder, ref$.decode = function(toonStr){
  var lines, firstLine, result;
  if (toonStr === '') {
    return {};
  }
  lines = toonStr.split('\n');
  if (lines.length === 0) {
    return {};
  }
  firstLine = lines[0].trim();
  if (firstLine.startsWith('[')) {
    result = this.parseArray(lines, 0, 0);
    return result.value;
  } else if (firstLine.indexOf(':') >= 0) {
    result = this.parseObject(lines, 0, 0);
    return result.value;
  } else {
    return this.parseValue(firstLine);
  }
}, ref$.parseObject = function(lines, startIdx, depth){
  var obj, expectedIndent, idx, line, currentIndent, trimmed, bracketPos, key, arrayDef, colonPos, afterColon, result, remainingLines, parsed, valueStr, isNested, nextIdx, nextLine, nextIndent, nextTrimmed;
  obj = {};
  expectedIndent = depth * 2;
  idx = startIdx;
  while (idx < lines.length) {
    line = lines[idx];
    currentIndent = this.getIndent(line);
    if (currentIndent < expectedIndent) {
      break;
    }
    if (currentIndent > expectedIndent) {
      idx++;
      continue;
    }
    trimmed = line.trim();
    if (!trimmed) {
      idx++;
      continue;
    }
    if (/^[^:]+\[.*\](\{[^}]+\})?:/.test(trimmed)) {
      bracketPos = trimmed.indexOf('[');
      key = trimmed.substring(0, bracketPos);
      arrayDef = trimmed.substring(bracketPos);
      colonPos = arrayDef.indexOf(':');
      afterColon = arrayDef.substring(colonPos + 1).trim();
      if (afterColon && !/^\[.*\]\{/.test(arrayDef)) {
        result = this.parseArray([arrayDef], 0, depth);
        obj[key] = result.value;
        idx++;
      } else {
        remainingLines = [arrayDef].concat(lines.slice(idx + 1));
        result = this.parseArray(remainingLines, 0, depth);
        obj[key] = result.value;
        idx = idx + result.nextIdx;
      }
    } else if (this.findColon(trimmed) >= 0) {
      parsed = this.parseKeyValue(trimmed);
      key = parsed.key;
      valueStr = parsed.value;
      isNested = parsed.isNested;
      if (isNested) {
        nextIdx = idx + 1;
        if (nextIdx < lines.length) {
          nextLine = lines[nextIdx];
          nextIndent = this.getIndent(nextLine);
          nextTrimmed = nextLine.trim();
          if (nextIndent > currentIndent) {
            if (nextTrimmed.startsWith('- ')) {
              result = this.parseList(lines, nextIdx, depth + 1);
              obj[key] = result.value;
              idx = result.nextIdx;
            } else if (/^\[.*\]\{/.test(nextTrimmed) || /^\[.*\]:/.test(nextTrimmed)) {
              result = this.parseArray(lines, nextIdx, depth + 1);
              obj[key] = result.value;
              idx = result.nextIdx;
            } else {
              result = this.parseObject(lines, nextIdx, depth + 1);
              obj[key] = result.value;
              idx = result.nextIdx;
            }
          } else {
            obj[key] = {};
            idx++;
          }
        } else {
          obj[key] = {};
          idx++;
        }
      } else {
        obj[key] = this.parseValue(valueStr);
        idx++;
      }
    } else {
      idx++;
    }
  }
  return {
    value: obj,
    nextIdx: idx
  };
}, ref$.parseArray = function(lines, startIdx, depth){
  var line, trimmed, colonPos, afterColon, nextIdx;
  if (startIdx >= lines.length) {
    return {
      value: [],
      nextIdx: startIdx + 1
    };
  }
  line = lines[startIdx];
  trimmed = line.trim();
  if (/^\[.*\]\{/.test(trimmed)) {
    return this.parseTabular(lines, startIdx, depth);
  } else if (/^\[.*\]:/.test(trimmed)) {
    colonPos = trimmed.indexOf(':');
    afterColon = trimmed.substring(colonPos + 1).trim();
    if (afterColon) {
      return this.parseInline(lines, startIdx, depth);
    } else {
      nextIdx = startIdx + 1;
      if (nextIdx < lines.length && lines[nextIdx].trim().startsWith('- ')) {
        return this.parseList(lines, startIdx, depth);
      } else {
        return this.parseInline(lines, startIdx, depth);
      }
    }
  } else {
    return {
      value: [],
      nextIdx: startIdx + 1
    };
  }
}, ref$.parseInline = function(lines, startIdx, depth){
  var line, m, length, delimiter, valuesStr, values, arr, this$ = this;
  line = lines[startIdx].trim();
  m = line.match(/^\[#?(\d+)(.?)\]:\s*(.*)$/);
  if (!m) {
    return {
      value: [],
      nextIdx: startIdx + 1
    };
  }
  length = parseInt(m[1], 10);
  delimiter = m[2] || ',';
  valuesStr = m[3];
  if (!valuesStr) {
    return {
      value: [],
      nextIdx: startIdx + 1
    };
  }
  values = this.splitValues(valuesStr, delimiter);
  arr = values.map(function(v){
    return this$.parseValue(v);
  });
  return {
    value: arr,
    nextIdx: startIdx + 1
  };
}, ref$.parseTabular = function(lines, startIdx, depth){
  var line, m, length, delimiter, fieldsStr, fields, arr, rowIndent, idx, i$, i, rowLine, currentIndent, trimmed, values, obj, j$, len$, j, field, this$ = this;
  line = lines[startIdx].trim();
  m = line.match(/^\[#?(\d+)(.?)\]\{([^}]+)\}:$/);
  if (!m) {
    return {
      value: [],
      nextIdx: startIdx + 1
    };
  }
  length = parseInt(m[1], 10);
  delimiter = m[2] || ',';
  fieldsStr = m[3];
  fields = this.splitValues(fieldsStr, delimiter);
  fields = fields.map(function(f){
    f = f.trim();
    if (f[0] === '"' && f[f.length - 1] === '"') {
      return this$.unquote(f);
    } else {
      return f;
    }
  });
  arr = [];
  rowIndent = (depth + 1) * 2;
  idx = startIdx + 1;
  for (i$ = 0; i$ < length; ++i$) {
    i = i$;
    if (idx >= lines.length) {
      break;
    }
    rowLine = lines[idx];
    currentIndent = this.getIndent(rowLine);
    if (currentIndent < rowIndent) {
      break;
    }
    trimmed = rowLine.trim();
    values = this.splitValues(trimmed, delimiter);
    obj = {};
    for (j$ = 0, len$ = fields.length; j$ < len$; ++j$) {
      j = j$;
      field = fields[j$];
      obj[field] = this.parseValue(values[j] || 'null');
    }
    arr.push(obj);
    idx++;
  }
  return {
    value: arr,
    nextIdx: idx
  };
}, ref$.parseList = function(lines, startIdx, depth){
  var firstLine, idx, arr, itemIndent, line, currentIndent, trimmed, content, parsed, obj, nextLine, nextIndent, nextTrimmed, parsed2, m, delimiter, valuesStr, values, innerArr, this$ = this;
  firstLine = lines[startIdx].trim();
  idx = startIdx;
  if (/^\[.*\]:$/.test(firstLine)) {
    idx++;
  }
  arr = [];
  itemIndent = (depth + 1) * 2;
  while (idx < lines.length) {
    line = lines[idx];
    currentIndent = this.getIndent(line);
    if (currentIndent < itemIndent) {
      break;
    }
    trimmed = line.trim();
    if (trimmed.startsWith('- ')) {
      content = trimmed.substring(2);
      if (content.indexOf(':') >= 0) {
        parsed = this.parseKeyValue(content);
        obj = {};
        obj[parsed.key] = this.parseValue(parsed.value);
        idx++;
        while (idx < lines.length) {
          nextLine = lines[idx];
          nextIndent = this.getIndent(nextLine);
          if (nextIndent <= itemIndent) {
            break;
          }
          nextTrimmed = nextLine.trim();
          if (nextTrimmed.startsWith('- ')) {
            break;
          }
          if (nextTrimmed.indexOf(':') >= 0) {
            parsed2 = this.parseKeyValue(nextTrimmed);
            obj[parsed2.key] = this.parseValue(parsed2.value);
          }
          idx++;
        }
        arr.push(obj);
      } else if (content.startsWith('[')) {
        m = content.match(/^\[#?(\d+)(.?)\]:\s*(.*)$/);
        if (m) {
          delimiter = m[2] || ',';
          valuesStr = m[3];
          values = this.splitValues(valuesStr, delimiter);
          innerArr = values.map(fn$);
          arr.push(innerArr);
        }
        idx++;
      } else {
        arr.push(this.parseValue(content));
        idx++;
      }
    } else {
      idx++;
    }
  }
  return {
    value: arr,
    nextIdx: idx
  };
  function fn$(v){
    return this$.parseValue(v);
  }
}, ref$.getIndent = function(line){
  var count, i$, len$, char;
  count = 0;
  for (i$ = 0, len$ = line.length; i$ < len$; ++i$) {
    char = line[i$];
    if (char !== ' ') {
      break;
    }
    count++;
  }
  return count;
}, ref$.findColon = function(str){
  var inQuote, i, char;
  inQuote = false;
  i = 0;
  while (i < str.length) {
    char = str[i];
    if (char === '"' && (i === 0 || str[i - 1] !== '\\')) {
      inQuote = !inQuote;
    } else if (char === ':' && !inQuote) {
      return i;
    }
    i++;
  }
  return -1;
}, ref$.parseKeyValue = function(str){
  var colonIdx, keyStr, valueStr, key, isNested;
  colonIdx = this.findColon(str);
  if (colonIdx < 0) {
    return {
      key: str,
      value: '',
      isNested: false
    };
  }
  keyStr = str.substring(0, colonIdx).trim();
  valueStr = str.substring(colonIdx + 1).trim();
  key = keyStr[0] === '"' && keyStr[keyStr.length - 1] === '"' ? this.unquote(keyStr) : keyStr;
  isNested = valueStr === '';
  return {
    key: key,
    value: valueStr,
    isNested: isNested
  };
}, ref$.parseValue = function(str){
  str = str.trim();
  if (str === 'null') {
    return null;
  }
  if (str === 'true') {
    return true;
  }
  if (str === 'false') {
    return false;
  }
  if (/^-?\d+(\.\d+)?$/.test(str)) {
    return parseFloat(str);
  }
  if (str[0] === '"' && str[str.length - 1] === '"') {
    return this.unquote(str);
  }
  return str;
}, ref$.unquote = function(str){
  var content;
  content = str.substring(1, str.length - 1);
  return content.replace(/\\n/g, '\n').replace(/\\r/g, '\r').replace(/\\t/g, '\t').replace(/\\"/g, '"').replace(/\\\\/g, '\\');
}, ref$.splitValues = function(str, delimiter){
  var values, current, inQuote, i, char;
  values = [];
  current = '';
  inQuote = false;
  i = 0;
  while (i < str.length) {
    char = str[i];
    if (char === '"') {
      if (i > 0 && str[i - 1] === '\\' && (i < 2 || str[i - 2] !== '\\')) {
        current += char;
      } else {
        inQuote = !inQuote;
        current += char;
      }
    } else if (char === delimiter && !inQuote) {
      values.push(current.trim());
      current = '';
    } else {
      current += char;
    }
    i++;
  }
  if (current || values.length === 0) {
    values.push(current.trim());
  }
  return values;
}, ref$);
encode = function(value, options){
  var enc;
  enc = new encoder(options);
  return enc.encode(value);
};
decode = function(toonStr, options){
  var dec;
  dec = new decoder(options);
  return dec.decode(toonStr);
};
if (typeof window != 'undefined' && window !== null) {
  window.encoder = encoder;
  window.decoder = decoder;
  window.encode = encode;
  window.decode = decode;
} else {
  module.exports = {
    encoder: encoder,
    decoder: decoder,
    encode: encode,
    decode: decode
  };
}
function import$(obj, src){
  var own = {}.hasOwnProperty;
  for (var key in src) if (own.call(src, key)) obj[key] = src[key];
  return obj;
}
function repeatString$(str, n){
  for (var r = ''; n > 0; (n >>= 1) && (str += str)) if (n & 1) r += str;
  return r;
}
